/*
 *  Author: VadRov
 *  Copyright (C) 2019, VadRov, all right reserved.
 *
 *  Драйвер инкрементарного механического энкодера.
 *
 *  Допускается свободное распространение.
 *  При любом способе распространения указание автора ОБЯЗАТЕЛЬНО.
 *  В случае внесения изменений и распространения модификаций указание первоначального автора ОБЯЗАТЕЛЬНО.
 *  Распространяется по типу "как есть", то есть использование осуществляется на свой страх и риск.
 *  Автор не предоставляет никаких гарантий.
 *
 *  Версия: для STM32F4
 *
 *	Требования:
 *	- три вывода МК, настроенные как входы с внешними прерыванием EXTI по спадающему и нарастающему фронтам;
 *	- системный таймер SysTick, настроенный на прерывания с частотой 1000 раз в секунду (используется для
 *	"системного времени" при установке временного порога для устранения дребезга и определения времени
 *	нажатия на кнопку);
 *	- инкрементарный механический энкодер с кнопкой, т.е. с тремя выходами: A, B, C (кнопка);
 *	- в идеале пара керамических конденсаторов 0.02-0.1 мкФ (по одному в параллель между выходами
 *	энкодера A и "землей", В и "землей");
 *	- подтяжка входов МК к питанию (внутренняя - опция Pull up либо внешняя - через резисторы).
 *
 *	Особенности и возможности:
 *	- Используются исключительно прерывания EXTI, что полностью исключает необходимость постоянного циклического
 *	опроса состояния энкодера, как это могло бы быть в случае использовании чрезмерно частых прерываний по обновлению
 *	таймера. Т.е. анализ состояний энкодера осуществляется только тогда, когда это требуется - по прерываниям,
 *	генерируемым по сигналам с его выходов.
 *	- Помехоустойчивость и четкость работы энкодера за счет алгоритма обработки состояний выходов энкодера и
 *	использования прерываний "в две стороны" (по спадающему - falling и нарастающему - rising фронтам на входах МК).
 *	- За счет применения прерываний "в две стороны" одновременно на двух выходах энкодера A и B нет необходимости в
 *	организации искусственных задержек в обработчике прерываний, как это можно встретить в различных источниках
 *	в сети, где используется только прерывание по спадающему фронту на одном из двух выходов энкодера. Также за
 *	счет применения	такого подхода снижаются требования к качеству энкодера. Драйвер, в целом, одинаково неплохо
 *	отрабатывает как медленные, так и быстрые вращения ручки энкодера.
 *	- Нет никаких искусственных задержек в программе драйвера.
 *	- Малая вычислительная нагрузка на ядро МК.
 *	- Драйвер генерирует 6 значимых событий: вращения ручки энкодера вперед/назад, кратковременного нажатия на кнопку и
 *	удержания кнопки, вращения ручки энкодера вперед/назад при нажатой кнопке.
 *	- Драйвер позволяет менять местами генерацию событий вращения вперед/назад и событий вращения вперед/назад при
 *	нажатой кнопке, т.е. допускает программное инвертирование направления работы энкодера без необходимости
 *	аппаратного переподключения выходов.
 *
 *  https://www.youtube.com/@VadRov
 *  https://dzen.ru/vadrov
 *  https://vk.com/vadrov
 *  https://t.me/vadrov_channel
 */

#include "encoder.h"
#include <string.h>

extern uint32_t millis; /* Глобальная переменная, инкрементируемая каждую миллисекунду
						   в прерывании системного таймера SysTick.						 */

enum {						/* Cостояние выходов энкодера: */
	   ENCODER_NONE = 0,	/* - нет ни одного активного выхода; */
	   ENCODER_A    = 1,	/* - активен выход A; */
	   ENCODER_B    = 2,	/* - активен выход B; */
	   ENCODER_AB   = 3,	/* - активны выходы A и B; */
	   ENCODER_C    = 4,	/* - активен выход С (кнопка); */
	   ENCODER_ABС  = 7		/* - активны выходы A, B, С. */
};

/* Таблица для определения приращений к счетчику энкодера в зависимости от состояния его выходов A, B. */
static const int8_t ENCODER_inc_tbl[] = {0, -1, 1, 0, 1, 0, 0, -1, -1, 0, 0, 1, 0, 1, -1, 0};

/* Инициализирует энкодер enc. */
void EncoderInit(ENCODER_Handler *enc,
				 GPIO_TypeDef *a_port, uint16_t a_pin,
				 GPIO_TypeDef *b_port, uint16_t b_pin,
				 GPIO_TypeDef *c_port, uint16_t c_pin)
{
	memset(enc, 0, sizeof(ENCODER_Handler)); /* Инициализация памяти обработчика энкодера */
	/* Назначение выводов портов, подключенных к выходам энкодера */
	enc->a_port = a_port; /* Выход энкодера A */
	enc->a_pin = a_pin;
	enc->b_port = b_port; /* Bыход энкодера B */
	enc->b_pin = b_pin;
	enc->c_port = c_port; /* Bыход энкодера C (кнопка) */
	enc->c_pin = c_pin;
}

/*
 * Опрашивает состояние выходов энкодера и обновляет его обработчик.
 * Возвращает одно из событий, которое сформировалось к моменту поступления запроса на обновление:
 * ENCODER_EV_NONE 		- нет событий;
 * ENCODER_EV_FWD 		- вращение ручки энкодера по часовой стрелке;
 * ENCODER_EV_BCK		- вращение ручки энкодера против часовой стрелки;
 * ENCODER_EV_BTN_CLICK	- кратковременное нажатие на кнопку;
 * ENCODER_EV_BTN_HOLD	- удержание кнопки;
 * ENCODER_EV_FWD_BTN	- вращение ручки энкодера по часовой стрелке при нажатой кнопке;
 * ENCODER_EV_BCK_BTN	- вращение ручки энкодера против часовой стрелки при нажатой кнопке.
 * enc - указатель на обработчик энкодера.
 * ch_irq - выход энкодера по которому поступил запрос на обновление.
 * ch_irq принимает значения ENCODER_IRQ_NONE, ENCODER_IRQ_A, ENCODER_IRQ_B, ENCODER_IRQ_C.
 * Функция EncoderUpdate должна вызываться из соответствующих обработчиков внешних EXTI прерываний.
 */
uint8_t EncoderUpdate(ENCODER_Handler *enc, uint8_t ch_irq)
{
	uint8_t event = ENCODER_EV_NONE; /* Инициализация текущего события: нет событий. */
	uint8_t keys = ENCODER_NONE;     /* Инициализация переменной состояния выходов энкодера: нет активных выходов. */

	/* Опрашиваем выходы энкодера (они же входы МК) и формируем в переменной keys значение,
	   соответствующее текущему состоянию выходов энкодера. */
	if (!(enc->a_port->IDR & enc->a_pin)) keys = ENCODER_A;  /* Активен выход A (прижат к "земле"): установим бит ENCODER_A. */
	if (!(enc->b_port->IDR & enc->b_pin)) keys |= ENCODER_B; /* Активен выход B (прижат к "земле"): установим бит ENCODER_B. */
	if (!(enc->c_port->IDR & enc->c_pin)) keys |= ENCODER_C; /* Активен выход C (прижат к "земле"): установим бит ENCODER_C. */

	if ((enc->prev_event == ENCODER_EV_FWD_BTN ||	/* Блокируем возможность "попутного" события в виде ENCODER_EV_BTN или   */
	    enc->prev_event == ENCODER_EV_BCK_BTN) &&	/* ENCODER_EV_BTN_HOLD при генерации событий ENCODER_EV_FWD_BTN и        */
		ch_irq == ENCODER_IRQ_C) {					/* ENCODER_EV_BCK_BTN, которые возникнут в момент отпускания кнопки.     */
		enc->fl_click_btn = 0;						/* Сбросим флаг нажатия кнопки. */
		enc->time_bounce_btn = millis + 3000;		/* Установим временной порог в 3 секунды для блокировки "попутных" событий.*/
		enc->prev_event = event;
		return event;
	}

	/* Определение событий вращения энкодера. События ENCODER_EV_FWD и ENCODER_EV_BCK. */
	if (ch_irq == ENCODER_IRQ_A || ch_irq == ENCODER_IRQ_B) { /* Если поступил запрос на обновление от выходов A или B. */
		int8_t inv = !enc->inversion ? 1: -1; //Знак режима работы энкодера: прямой(+)/инверсный(-)
		enc->inc_idx <<= 2; /* Предыдущее состояние выходов энкодера, выраженное в значении индекса inc_idx,
    						   определяет базовое значение индекса в таблице приращений для анализа текущего
    						   состояния и выявления событий энкодера. Сдвигаемся по таблице от текущего
    						   индекса inc_idx на индекс inc_idx * 4. */
		enc->inc_idx |= keys & ENCODER_AB;  /* В зависимости от текущего состояния выходов энкодера добавляем
    										   смещение к полученному индексу. Это смещение принимает значение
    										   от 0 до 3 (два бита, определяющие выходы, дают 4 возможных комбинации). */
		/* Инкрементируем счетчик энкодера значением, зависящим от значения приращения, полученного из
		   таблицы, и режима работы энкодера (прямой или инверсный). При этом ограничиваем значение индекса inc_idx
		   4 младшими разрядами (значение индекса inc_idx в интервале от 0 до 15).                                  */
		enc->encCounter += inv * ENCODER_inc_tbl[enc->inc_idx & (sizeof(ENCODER_inc_tbl) - 1)];
		/* Проверяем, выполняются ли условия для генерации событий. */
		if (enc->encCounter >= ENCODER_THRESHOLD) { /* Счетчик достиг порога для события ENCODER_EV_FWD? */
			event = ENCODER_EV_FWD;	/* Событие ENCODER_EV_FWD. */
			if (keys & ENCODER_C) {
				event = ENCODER_EV_FWD_BTN; /* Если нажата кнопка, то событие ENCODER_EV_FWD_BTN. */
				enc->fl_click_btn = 0;		/* Сбросим флаг нажатой кнопки */
			}
			enc->inc_idx = enc->encCounter = 0; 	/* Инициализация счетчика энкодера. */
		}
		else if (enc->encCounter <= -ENCODER_THRESHOLD) { /* Счетчик достиг порога для события ENCODER_EV_BCK? */
			event = ENCODER_EV_BCK; /* Событие ENCODER_EV_BCK. */
			if (keys & ENCODER_C) {
				event = ENCODER_EV_BCK_BTN; /* Если нажата кнопка, то событие ENCODER_EV_BCK_BTN. */
				enc->fl_click_btn = 0;		/* Сбросим флаг нажатой кнопки */
			}
			enc->inc_idx = enc->encCounter = 0;	/* Инициализация счетчика энкодера. */
		}
	}
	/* Определение событий кратковременного нажатия и удержания кнопки энкодера.
	   События ENCODER_EV_BTN_CLICK и ENCODER_EV_BTN_HOLD.                       */
	else if (ch_irq == ENCODER_IRQ_C) { /* Если поступил запрос на обновление от выхода С (кнопка). */
		if (enc->time_bounce_btn <= millis) { /* Достигло ли текущее системное время заданного значения (порог)
											     для устранения дребезга при нажатии и отпускании кнопки?   */
			keys &= ENCODER_C;				  /* Получаем состояние выхода С, выделив его из совокупности выходов. */
			if (enc->fl_click_btn && !keys) { /* Мы попали в обработчик, потому что отпустили кнопку? */
				enc->fl_click_btn = 0;									/* Сбросим флаг нажатия кнопки. */
				enc->time_bounce_btn = millis + ENCODER_BTN_BOUNCE;		/* Установим временной порог для устранения дребезга при отпускании кнопки. */
				event = ENCODER_EV_BTN_CLICK;							/* Определим событие: кратковременное нажание на кнопку. */
				if (millis - enc->time_click_btn >= ENCODER_BTN_HOLD) { /* Длительность нажатия на кнопку достигла времени удержания? */
					event = ENCODER_EV_BTN_HOLD;						/* Если да, то определим событие: удержание кнопки. */
				}
			}
			else if (!enc->fl_click_btn && keys) {	/* Мы попали в обработчик, потому что нажали кнопку? */
				enc->fl_click_btn = 1;				/* Установим флаг нажатия кнопки. */
				enc->time_click_btn = millis;		/* Запомним текущее системное время для вычисления длительности удержания кнопки. */
				enc->time_bounce_btn = millis + ENCODER_BTN_BOUNCE; /* Установим временной порог для устранения дребезга при нажатии кнопки. */
			}
		}
	}
	enc->prev_event = event;
	return event; /* Возвращаем текущее событие. */
}

/*
 * Функция определяет режим работы энкодера: прямой (inv = ENCODER_INV_OFF) и обратный/инверсный (inv = ENCODER_INV_ON).
 * При инверсном режиме работы меняются местами события энкодера: ENCODER_EV_FWD с ENCODER_EV_BCK,
 * ENCODER_EV_FWD_BTN с ENCODER_EV_BCK_BTN.
 */
void inline EncoderSetInversion(ENCODER_Handler *enc, uint8_t inv)
{
	enc->inversion = inv;
}
